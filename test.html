<!doctype html>
<meta charset=utf-8>
<title>Geometric Construction Search</title>
<style>
.tbd{color:gray}
.fail{color:crimson}
dd{margin-left:5em;text-indent:-2.5em}
</style>
<script src=src/constructible_number.js></script>
<script src=src/geometry.js></script>
<script src=src/test.js></script>

<h1>Geometric Construction Search</h1>
<dl>
<script>
"use strict";

module("ConstructibleNumber", () => {
  test("should define helpful constants", () => {
    assert_equal(Literal.NEGATIVE_ONE, -1);
    assert_equal(Literal.ZERO, 0);
    assert_equal(Literal.ONE, 1);
    assert_equal(Literal.TWO, 2);
    assert_equal(Literal.THREE, 3);
    assert_equal(Fraction.ONE_HALF, "1/2");
    assert_equal(Fraction.ONE_OVER_ROOT_TWO, "1/√2");
    assert_equal(Fraction.ROOT_TWO_OVER_TWO, "√2/2");
    assert_equal(Fraction.ROOT_THREE_OVER_TWO, "√3/2");
    assert_equal(SquareRoot.ROOT_TWO, "√2");
    assert_equal(SquareRoot.ROOT_THREE, "√3");
  });

  test("should add two literals", () => {
    assert_equal(Literal.ONE.plus(Literal.TWO), 3);
    assert_equal(Literal.TWO.plus(Literal.TWO), 4);
  });

  test("should subtract two literals", () => {
    assert_equal(new Literal(100).minus(new Literal(87)), 13);
  });

  test("should multiply two literals", () => {
    assert_equal(new Literal(6).times(new Literal(7)), 42);
  });

  test("should multiply a literal by a fraction", () => {
    assert_equal(Literal.THREE.times(Literal.TWO.dividedBy(Literal.THREE)), 2);
    assert_equal(Literal.THREE.times(Fraction.ONE_HALF), "3/2");
  });

  test("should multiply a literal by a square root", () => {
    assert_equal(Literal.THREE.times(SquareRoot.ROOT_THREE), "√27");
  });

  test("should fail to divide by zero", () => {
    assert_throws(
      () => Literal.THREE.dividedBy(Literal.ZERO),
      "Cannot divide by zero",
    );
  });

  test("should return a literal when dividing by one", () => {
    assert_equal(new Literal(42).dividedBy(Literal.ONE), 42);
  });

  test("should reduce a literal when it is divisible", () => {
    assert_equal(new Literal(42).dividedBy(new Literal(6)), 7);
  });

  test("should reduce a literal to lowest terms", () => {
    assert_equal(new Literal(12).dividedBy(new Literal(8)), "3/2");
  });

  test("should divide by negative one", () => {
    assert_equal(new Literal(5).dividedBy(new Literal(-1)), "-5");
    assert_equal(new Literal(-5).dividedBy(new Literal(-1)), "5");
  });

  test("should square a literal", () => {
    assert_equal(new Literal(12).squared(), 144);
  });

  test("should simplify the square root of a square literal", () => {
    assert_equal(new Literal(25).squareRoot(), 5);
  });

  test("should not simplify the square root of a prime", () => {
    assert_equal(new Literal(65537).squareRoot(), "√65537");
  });

  test("should compare two literals", () => {
    assert(Literal.ONE.lessThan(Literal.TWO), "1<2");
    assert(!Literal.TWO.lessThan(Literal.ONE), "1≮2");
    assert(Literal.ONE.equals(Literal.ONE), "1=1");
    assert(!Literal.ONE.equals(Literal.TWO), "1≠2");
    assert(!Literal.TWO.equals(Literal.ONE), "2≠1");
    assert(Literal.TWO.greaterThan(Literal.ONE), "2>1");
    assert(!Literal.ONE.greaterThan(Literal.TWO), "1≯2");
  });

  test("should compare a literal with a fraction");

  test("should compare a literal with a square root");

  test("should square a fraction", () => {
    assert_equal(Fraction.ONE_HALF.squared(), "1/4");
    assert_equal(Literal.THREE.dividedBy(Literal.TWO).squared(), "9/4");
  });

  test("should square root a fraction", () => {
    assert_equal(new Literal(5).dividedBy(new Literal(4)).squareRoot(), "√5/2");
  });

  test("should compare a fraction with a literal");

  test("should compare a fraction with a fraction");

  test("should compare a fraction with a square root");

  test("should multiply a square root by a literal", () => {
    assert_equal(SquareRoot.ROOT_THREE.times(Literal.THREE), "√27");
  });

  test("should multiply a square root by a fraction");

  test("should multiply a square root by itself", () => {
    assert_equal(SquareRoot.ROOT_TWO.times(SquareRoot.ROOT_TWO), 2);
  });

  test("should multiply a square root by a square root", () => {
    assert_equal(SquareRoot.ROOT_TWO.times(SquareRoot.ROOT_THREE), "√6");
    assert_equal(SquareRoot.ROOT_TWO.times(new Literal(5).squareRoot()), "√10");
  });

  test("should square a square root", () => {
    assert_equal(SquareRoot.ROOT_THREE.squared(), 3);
  });

  test("should square root a square root", () => {
    assert_equal(SquareRoot.ROOT_TWO.squareRoot(), "√√2");
  });

  test("should compare a square root to a literal", () => {
    assert(!SquareRoot.ROOT_TWO.lessThan(Literal.ONE), "√2≮1");
    assert(SquareRoot.ROOT_TWO.lessThan(Literal.TWO), "√2<2");
    assert(!SquareRoot.ROOT_TWO.equals(Literal.TWO), "√2≠2");
    assert(SquareRoot.ROOT_TWO.greaterThan(Literal.ONE), "√2>1");
    assert(!SquareRoot.ROOT_TWO.greaterThan(Literal.TWO), "√2≯2");
  });

  test("should compare a square root to a fraction");

  test("should compare a square root to a square root", () => {
    assert(!SquareRoot.ROOT_TWO.lessThan(SquareRoot.ROOT_TWO), "√2≮√2");
    assert(SquareRoot.ROOT_TWO.lessThan(SquareRoot.ROOT_THREE), "√2<√3");
    assert(SquareRoot.ROOT_TWO.equals(SquareRoot.ROOT_TWO), "√2=√2");
    assert(!SquareRoot.ROOT_TWO.equals(SquareRoot.ROOT_THREE), "√2≠√3");
    assert(SquareRoot.ROOT_THREE.greaterThan(SquareRoot.ROOT_TWO), "√3>√2");
    assert(!SquareRoot.ROOT_THREE.greaterThan(SquareRoot.ROOT_THREE), "√3≯√3");
  });
});

module("Geometry", () => {
  test("should calculate the diagonal of a unit square", () => {
    assert_equal(
      new Point(Literal.ZERO, Literal.ZERO).
        distanceTo(new Point(Literal.ONE, Literal.ONE)),
      "√2"
    );
  });

  test("should calculate Pythagorean triples", () => {
    assert_equal(
      new Point(Literal.THREE, Literal.ZERO).
        distanceTo(new Point(Literal.ZERO, new Literal(4))),
      5
    );
    assert_equal(
      new Point(new Literal(5), Literal.ZERO).
        distanceTo(new Point(Literal.ZERO, new Literal(12))),
      13
    );
  });

  test("should make unit circles", () => {
    assert_equal(
      Point.ORIGIN.circleTo(new Point(Literal.ONE, Literal.ZERO)),
      Circle.UNIT,
    );
    assert_equal(
      Point.ORIGIN.circleTo(new Point(Fraction.ROOT_THREE_OVER_TWO, Fraction.ONE_HALF)),
      Circle.UNIT,
    );
    assert_equal(
      Point.ORIGIN.circleTo(new Point(Fraction.ONE_OVER_ROOT_TWO, Fraction.ONE_OVER_ROOT_TWO)),
      Circle.UNIT,
    );
    assert_equal(
      Point.ORIGIN.circleTo(new Point(Fraction.ONE_HALF, Fraction.ROOT_THREE_OVER_TWO)),
      Circle.UNIT,
    );
    assert_equal(
      Point.ORIGIN.circleTo(new Point(Literal.ZERO, Literal.ONE)),
      Circle.UNIT,
    );
  });
});
</script>
</dl>
